#include "ph3.h"
#include "usart.h"
#include "delay.h"
#include "string.h"
#include "main.h"

#define PH3_VDD GPIO_Pin_9

extern char usart2RxCnt, usart2RxBuffer[usart2RxBufferSize];
extern void UART1_send_byte(char data);

static float ph32Kppm = 0;
static float ph32KppmAver = 0;

static float ph35ppm = 0;
static float ph35ppmAver = 0;

void DisablePH3()
{
	#ifndef DPH3
	GPIO_ResetBits(GPIOB,PH3_VDD);
	#endif
}

void EnablePH3(){
	//芯片使能初始化
	USART_Cmd(USART2, DISABLE);                    //使能串口 
	GPIO_InitTypeDef    GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin = PH3_VDD;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//push-pull
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;//100MHz
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//
	GPIO_Init(GPIOB,&GPIO_InitStructure);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);	
	GPIO_SetBits(GPIOB,PH3_VDD);
	delay_ms(3000);
	USART_Cmd(USART2, ENABLE);                    //使能串口 
}

uint32_t bcd2int(uint8_t *bcd, uint8_t len, bool isBig)
{
	uint32_t val = 0;
	uint32_t power = 1;
  uint8_t i = 0;
  uint8_t idx = 0;
    
	for(i=0; i<len; i++)
	{
		if(isBig)
		{
			idx = len - 1 - i;
		}
		else
		{
			idx = i;
		}
		val += (bcd[idx]&0x0f)*power;
		power *= 10;
		val += ((uint8_t)(bcd[idx]>>4)&0x0f)*power;
		power *= 10;
	}
	return val;
}

bool Ph32KUnpack(uint8_t *data, uint8_t len)
{
	Ph32kFrame *ph32k = (Ph32kFrame *)&data[0];
	float power = 1;
	uint8_t i = 0;
	uint8_t crc = 0;

	power = 1;
	for(i=0; i<len; i++)
	{
		if(len-i < sizeof(Ph32kFrame))
		{
			return false;
		}
		
		ph32k = (Ph32kFrame *)&data[i];
		if(1 != ph32k->type)
		{
			continue;
		}

		if(1 != ph32k->addr)
		{
			continue;
		}

		if(0x0C != ph32k->len)
		{
			continue;
		}

		if(0xA1 != ph32k->cmd)
		{
			continue;
		}

		if(0x00 != ph32k->regH)
		{
			continue;
		}
		
		if(0x6C != ph32k->regL)
		{
			continue;
		}	

		if(0x07 != ph32k->dataLen)
		{
			continue;
		}

		if(0x0F != ph32k->name)
		{
			continue;
		}

		if(0x02 != ph32k->unit)
		{
			continue;
		}

		if(0xDD != ph32k->eof)
		{
			continue;
		}

		crc+=ph32k->cmd;
		crc+=ph32k->regH;
		crc+=ph32k->regL;
		crc+=ph32k->dataLen;
		crc+=ph32k->state;
		crc+=ph32k->val[0];
		crc+=ph32k->val[1];
		crc+=ph32k->val[2];
		crc+=ph32k->digits;
		crc+=ph32k->name;
		crc+=ph32k->unit;
		if (crc!=ph32k->crc)
		{
			continue;
		}
		if (ph32k->val[0]!=0xff)
		{
				if ((ph32k->val[0]==0xAA)&&(ph32k->val[1]==0xAA)&&(ph32k->val[2]==0xAA))
				{
					ph32Kppm = 2000;
				}
				else
				{
					ph32Kppm = bcd2int(ph32k->val, 3, true);
				}
		}
		else
		{
				ph32Kppm = bcd2int(&ph32k->val[1], 2, true);
				ph32Kppm = -ph32Kppm;
				//ph32Kppm = 0;
		}
		for(i=0; i<ph32k->digits; i++)
		{
			power *= 10;
		}
		ph32Kppm /= power;
		if (ph32Kppm>10000) 
		{
			Uart1_SendStr("2000ppm读取过大！ \r\n");
			for (i=0;i<len;i++)
			{
				UART1_send_byte(data[i]);
			}
			Uart1_SendStr("\r\n");
			return false;
		}
		break;
	}

	return true;
}


float Ph32KppmSample(void)
{
	uint8_t data[11] = {0xFF, 0xFF, 0x01, 0x01, 0x05, 0x01, 0x00, 0x6C, 0x07, 0x74, 0xDD};
	float ppmSum = 0;
	uint8_t sampleCnt = 0;
  uint8_t i = 0;
	uint8_t tmpstmp;
		
	for(i=0; i<5; i++)
	{
		usart2RxCnt = 0;
		memset(usart2RxBuffer,0,usart2RxBufferSize);
		Uart2_SendData((char *)data, 11);
		tmpstmp=0;
		while ((usart2RxCnt<18)&&(tmpstmp<5))
		{
			delay_ms(200);
			tmpstmp++;
		}
		if (usart2RxCnt<18) continue; 	
		if(!Ph32KUnpack((uint8_t *)usart2RxBuffer, usart2RxCnt))
		{
			Uart1_SendStr("2000ppm读取失败！ \r\n");
			continue;
		}
		ppmSum += ph32Kppm;
		sampleCnt++;
	}
	ph32KppmAver = ppmSum / sampleCnt;
/*	if (ph32KppmAver>10000)
	{
			Uart1_SendStr("2000ppm读取过大！ \r\n");
			Uart1_SendStr(usart2RxBuffer);
			Uart1_SendStr("\r\n");
	}*/
	if (sampleCnt==0)
	{
			Uart1_SendStr("2000ppm读取成功次数为0！ \r\n");
			Uart1_SendStr(usart2RxBuffer);
			Uart1_SendStr("\r\n");
	}
    
    return ph32KppmAver;
}

float GetPH32Kppm(void)
{
	return ph32KppmAver;
}

//用于CRC校验
const  char auchCRCHi[256]={    
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,    
	0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,    
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,    
	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,    
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,    
	0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,    
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,    
	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,    
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,    
	0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,    
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,    
	0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,    
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,    
	0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,    
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,    
	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,    
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,    
	0x40};

const  char auchCRCLo[256]={
  0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,    
	0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,    
	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,    
	0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,    
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,    
	0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,    
	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,    
	0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,    
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,    
	0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,    
	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,    
	0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,    
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,    
	0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,    
	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,    
	0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,    
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,    
	0x40};
/**function：unsigned int CRC16(unsigned char *puchMsg,unsigned int  usDataLen)*decription:  计算CRC校验码*input:*output:*/
unsigned int CRC16(unsigned char *puchMsg,unsigned int  usDataLen)
{    
	unsigned char uchCRCHi,uchCRCLo;    
	unsigned char uIndex=0 ;                             
	/* will index into CRC lookup table */    
	unsigned char tempp=0;    
	unsigned int CRCHL=0;    
	uchCRCHi=0xFF ;                             // high byte of CRC initialized     
	uchCRCLo=0xFF ;     
	tempp=0;                           // low byte of CRC initialized     
	while(usDataLen--)                       // pass through message buffer     
	{        
		uIndex=uchCRCHi^*puchMsg++ ; // calculate the CRC high byte                 
		tempp++;        
		uchCRCHi=uchCRCLo^auchCRCHi[uIndex] ;//01-auchCRCHi[254]:0x81;02-0x01;03-0x80;04-0xC0        
		uchCRCLo=auchCRCLo[uIndex] ;                   
	}    
	CRCHL=uchCRCHi;    
	CRCHL=CRCHL<<8;    
	CRCHL|=uchCRCLo;            
	return CRCHL;//(uchCRCHi<<8|uchCRCLo) ;//uchCRCHi:0xa1;uchCRCLo:2B
}

	
	
	
bool Ph35Unpack(uint8_t *data, uint8_t len)
{
	Ph35Frame *ph35 = (Ph35Frame *)&data[0];
	uint8_t i = 0;
	uint16_t tmpcrc = 0;
	float tmp;

	for(i=0; i<len; i++)
	{
		if(len-i < sizeof(Ph35Frame))
		{
			return false;
		}
		
		ph35 = (Ph35Frame *)&data[i];
		if(0xAA != ph35->sof)
		{
			continue;
		}

		if(1 != ph35->cmd)
		{
			continue;
		}

		if(1 != ph35->addr)
		{
			continue;
		}

		if(0xEE != ph35->eof)
		{
			continue;
		}
		
		tmpcrc=ph35->crcH;
		tmpcrc=(tmpcrc<<8)+ph35->crcL;
		
		if (tmpcrc!=CRC16(&data[i+1],6))
		{
			continue;
		}
		
		tmp=ph35->point;
		tmp=tmp/100;
		ph35ppm = (((uint16_t)ph35->dec[0])<<8) + (uint16_t)ph35->dec[1] + tmp;
		if(ph35->sign == 0x80)
		{
			ph35ppm = -ph35ppm;
			//ph35ppm = 0;
		}

		break;
	}

	return true;
}

float Ph35ppmSample(void)
{
	uint8_t data[6] = {0xAA, 0x01, 0x01, 0xC1, 0xE0, 0xEE};
	float ppmSum = 0;
	uint8_t sampleCnt = 0;
    uint8_t i = 0;
    uint8_t tmpstmp = 0;
		
	for(i=0; i<5; i++)
	{
		usart2RxCnt = 0;
		memset(usart2RxBuffer,0,usart2RxBufferSize);
		Uart2_SendData((char *)data, 6);
		tmpstmp=0;
		while ((usart2RxCnt<10)&&(tmpstmp<5))
		{
			delay_ms(200);
			tmpstmp++;
		}
		if (usart2RxCnt<5) continue; 	
		if(!Ph35Unpack((uint8_t *)usart2RxBuffer, usart2RxCnt))
		{
			Uart1_SendStr("5ppm读取失败！ \r\n");
			continue;
		}
		ppmSum += ph35ppm;
		sampleCnt++;
	}
	ph35ppmAver = ppmSum / sampleCnt;
    
	if (ph35ppmAver>10000)
	{
			Uart1_SendStr("5ppm读取过大！ \r\n");
			Uart1_SendStr(usart2RxBuffer);
			Uart1_SendStr("\r\n");
	}
	if (sampleCnt==0)
	{
			Uart1_SendStr("5ppm读取成功次数为0！ \r\n");
			Uart1_SendStr(usart2RxBuffer);
			Uart1_SendStr("\r\n");
	}

	return ph35ppmAver;
}

float Ph35ppmSampleMAX(void)
{
	float ph35ppmMAX = 0;

	uint8_t data[6] = {0xAA, 0x01, 0x01, 0xC1, 0xE0, 0xEE};
    uint8_t i = 0;
		
	ph35ppmMAX=0;
	for(i=0; i<5; i++)
	{
		usart2RxCnt = 0;
		Uart2_SendData((char *)data, 6);
		delay_ms(5000);
		if(!Ph35Unpack((uint8_t *)usart2RxBuffer, usart2RxCnt))
		{
			Uart1_SendStr("5ppm读取失败！ \r\n");
			continue;
		}
		if (ph35ppmMAX<ph35ppm) ph35ppmMAX=ph35ppm;
	}
    
    return ph35ppmMAX;
}


float GetPH35ppm(void)
{
	return ph35ppmAver;
}









