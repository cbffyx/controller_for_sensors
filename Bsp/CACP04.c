#include "SHT2x.h"
#include "ms5637.h"
#include <stdio.h>
#include "CACP04.h"
#include "string.h"
#include "protocal.h"

#define CACP04_ADDR 0x28 //0b0101000

#define CACP04_OPCode_Read_NVRAM						0x2000
#define CACP04_OPCode_Write_NVRAM						0xA000
#define CACP04_OPCode_Read_Configuration		0x23C0
#define CACP04_OPCode_Write_Configuration		0xA3C0
#define CACP04_OPCode_Read_Result						0x40
#define CACP04_OPCode_Power_on_Reset				0x88
#define CACP04_OPCode_Initialize						0x8A
#define CACP04_OPCode_CDC_Start_Conversion	0x8C
#define CACP04_OPCode_RDC_Start_Conversion	0x8E
#define CACP04_OPCode_Test_read							0x7E//0x7E11
extern SensorSInfo sensorReal;






/**
 * \brief Configures the SERCOM I2C master to be used with the MS5637 device.
 */
void CACP04_init(void)
{
    /* Initialize and enable device with config. */
    i2c_master_init();
}

enum status_code CACP04_Read_NVRAM(uint16_t addr,uint8_t *buf,uint16_t len)
{
    uint8_t ack;
    uint16_t address;
    uint16_t i;

    if (len==0)
    {
        return STATUS_OK;
    }
    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    address=CACP04_OPCode_Read_NVRAM|(addr&0x03ff);//op_code+address
    IIC_Send_Byte(address>>8);                   //send high
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(address&0x00ff);               //send low
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Start();																	//Start
    IIC_Send_Byte((CACP04_ADDR<<1)|0x01);        //IIC_Address+R
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    for (i=0; i<len; i++)
    {
        if (i==(len-1))
        {
            buf[i]=IIC_Read_Byte(0);						//receive a byte with NoAck
        }
        else
        {
            buf[i]=IIC_Read_Byte(1);						//receive a byte with Ack
        }
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}

enum status_code CACP04_Write_NVRAM(uint16_t addr,uint8_t *buf,uint16_t len)
{
    uint8_t ack;
    uint16_t address;
    uint16_t i;

    if (len==0)
    {
        return STATUS_OK;
    }
    IIC_Start();
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    address=CACP04_OPCode_Write_NVRAM|(addr&0x03ff);//op_code+address
    IIC_Send_Byte(address>>8);                   //send high
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(address&0x00ff);							//send low
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    for (i=0; i<len; i++)
    {
        IIC_Send_Byte(buf[i]);               		//send data
        ack = IIC_Wait_Ack();
        if(ack != 0)
        {
            return STATUS_ERR_OVERFLOW;
        }
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}

enum status_code CACP04_Read_Configuration(uint8_t addr,uint8_t *buf,uint8_t len)
{
    uint8_t ack;
    uint16_t address;
    uint16_t i;

    if (len==0)
    {
        return STATUS_OK;
    }
    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    delay_ms(1);
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    address=CACP04_OPCode_Read_Configuration;
		address|=(addr&0x3f);									//op_code+address
    IIC_Send_Byte(address>>8);            //send high
    delay_ms(1);
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(address&0x00ff);               //send low
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Start();																	//Start
    IIC_Send_Byte((CACP04_ADDR<<1)|0x01);        //IIC_Address+R
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    for (i=0; i<len; i++)
    {
        if (i==(len-1))
        {
            buf[i]=IIC_Read_Byte(0);						//receive a byte with NoAck
        }
        else
        {
            buf[i]=IIC_Read_Byte(1);						//receive a byte with Ack
        }
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}

/*
enum status_code CACP04_Read_Configuration(uint8_t addr,uint8_t *buf,uint8_t len)
{
    uint8_t ack;
    uint16_t address;
    uint16_t i;

    if (len==0)
    {
        return STATUS_OK;
    }
    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)|0x01);	//IIC_Address+R
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    address=CACP04_OPCode_Read_Configuration;
		address|=(addr&0x3f);									//op_code+address
    IIC_Send_Byte(address>>8);            //send high
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(address&0x00ff);               //send low
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    for (i=0; i<len; i++)
    {
        if (i==(len-1))
        {
            buf[i]=IIC_Read_Byte(0);						//receive a byte with NoAck
        }
        else
        {
            buf[i]=IIC_Read_Byte(1);						//receive a byte with Ack
        }
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}
*/

enum status_code CACP04_Write_Configuration(uint8_t addr,uint8_t *buf,uint8_t len)
{
    uint8_t ack;
    uint16_t address;
    uint16_t i;

    if (len==0)
    {
        return STATUS_OK;
    }
    IIC_Start();
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    address=CACP04_OPCode_Write_Configuration;
		address|=(addr&0x3f);								//op_code+address
    IIC_Send_Byte(address>>8);                   //send high
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(address&0x00ff);							//send low
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    for (i=0; i<len; i++)
    {
        IIC_Send_Byte(buf[i]);               		//send data
        ack = IIC_Wait_Ack();
        if(ack != 0)
        {
            return STATUS_ERR_OVERFLOW;
        }
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}

double CACP04_Result_Double(uint8_t *buf)
{
	double result,zhengshu/*,xiaoshu*/;
//	double *p;
	
//	uint8_t tbuf[8];

	zhengshu=(uint8_t)(buf[3]>>3);
	result=zhengshu;
	if (buf[3]&0x04) result+=0.5;
	if (buf[3]&0x02) result+=0.25;
	if (buf[3]&0x01) result+=0.125;
	if (buf[2]&0x80) result+=0.0625;
	if (buf[2]&0x40) result+=0.03125;
	if (buf[2]&0x20) result+=0.015625;
	if (buf[2]&0x10) result+=0.0078125;
	if (buf[2]&0x08) result+=0.00390625;
	if (buf[2]&0x04) result+=0.001953125;
	if (buf[2]&0x02) result+=0.0009765625;
	if (buf[2]&0x01) result+=0.00048828125;
	if (buf[1]&0x80) result+=0.000244140625;
	if (buf[1]&0x40) result+=0.0001220703125;
	if (buf[1]&0x20) result+=0.00006103515625;
	if (buf[1]&0x10) result+=0.000030517578125;
	if (buf[1]&0x08) result+=0.0000152587890625;
	if (buf[1]&0x04) result+=0.00000762939453125;
	if (buf[1]&0x02) result+=0.000003814697265625;
	if (buf[1]&0x01) result+=0.0000019073486328125;
	if (buf[0]&0x80) result+=0.00000095367431640625;
	if (buf[0]&0x40) result+=0.000000476837158203125;
	if (buf[0]&0x20) result+=0.0000002384185791015625;
	if (buf[0]&0x10) result+=0.00000011920928955078125;
	if (buf[0]&0x08) result+=0.000000059604644775390625;
	if (buf[0]&0x04) result+=0.0000000298023223876953125;
	if (buf[0]&0x02) result+=0.00000001490116119384765625;
	if (buf[0]&0x01) result+=0.000000007450580596923828125;
	/*
	tbuf[7]=0x3F;
	tbuf[6]=0xE0|(((buf[3]&0x07)<<1)+(buf[2]>>7));
	tbuf[5]=(buf[2]<<1)|(buf[1]>>7);
	tbuf[4]=(buf[1]<<1)|(buf[0]>>7);
	tbuf[3]=(buf[0]<<1);
	tbuf[2]=0;
	tbuf[1]=0;
	tbuf[0]=0;
	
	p=(double *)tbuf;
	xiaoshu=*p;
	
	result=zhengshu+xiaoshu;*/
	return result;
}

float CACP04_Result_Float(uint8_t *buf)
{
	float result/*,zhengshu,xiaoshu*/;
	float *p;
	
	uint8_t tbuf[4];

/*	zhengshu=(uint8_t)(buf[0]>>3);
	
	tbuf[3]=0x3F;
	tbuf[2]=0x00|(((buf[0]&0x07)<<4)+(buf[1]>>4));
	tbuf[1]=(buf[1]<<4)|(buf[2]>>4);
	tbuf[0]=(buf[2]<<4)|(buf[3]>>4);
	
	p=(float *)tbuf;
	xiaoshu=*p;
	
	result=zhengshu+xiaoshu;*/
	
	tbuf[3]=0x41;
	tbuf[2]=0x80|(((buf[3]&0x07)<<4)+(buf[2]>>4));
	tbuf[1]=(buf[2]<<4)|(buf[1]>>4);
	tbuf[0]=(buf[1]<<4)|(buf[0]>>4);
	
	p=(float *)tbuf;
	result=*p;
	return result;
}

enum status_code CACP04_Read_Result(uint8_t addr,double *Result)
{
    uint8_t ack;
    uint8_t address;
    uint16_t i;
		uint8_t buf[4];

    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    address=CACP04_OPCode_Read_Result;
		address|=(addr&0x3f);									//op_code+address
    IIC_Send_Byte(address);            		//send address
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Start();																	//Start
    IIC_Send_Byte((CACP04_ADDR<<1)|0x01);        //IIC_Address+R
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    for (i=0; i<4; i++)
    {
        if (i==3)
        {
            buf[i]=IIC_Read_Byte(0);						//receive a byte with NoAck
        }
        else
        {
            buf[i]=IIC_Read_Byte(1);						//receive a byte with Ack
        }
    }
    IIC_Stop();
    delay_ms(10);
		*Result=CACP04_Result_Double(buf);
    return STATUS_OK;
}

enum status_code CACP04_Read_Status(uint8_t addr,uint8_t *buf)//0,1,2
{
    uint8_t ack;
    uint8_t address;

		if (addr>2) 
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    address=CACP04_OPCode_Read_Result;
		address|=((addr+32)&0x3f);									//op_code+address
    IIC_Send_Byte(address);            		//send address
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Start();																	//Start
    IIC_Send_Byte((CACP04_ADDR<<1)|0x01);        //IIC_Address+R
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    buf[0]=IIC_Read_Byte(0);						//receive a byte with NoAck
    IIC_Stop();
    return STATUS_OK;
}
/////////////////////////////////////////////////////////////Next Command

enum status_code CACP04_Initialize()
{
    uint8_t ack;   

    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(CACP04_OPCode_Initialize);            		//send op_code
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Stop();
    return STATUS_OK;
}

enum status_code CACP04_Power_on_Reset()
{
    uint8_t ack;

    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(CACP04_OPCode_Power_on_Reset);            		//send op_code
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}

enum status_code CACP04_CDC_Start_Conversion()
{
    uint8_t ack;

    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(CACP04_OPCode_CDC_Start_Conversion);            		//send op_code
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}

enum status_code CACP04_RDC_Start_Conversion()//Temperature
{
    uint8_t ack;

    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(CACP04_OPCode_RDC_Start_Conversion);            		//send op_code
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Stop();
    delay_ms(10);
    return STATUS_OK;
}

enum status_code CACP04_Test_read()
{
    uint8_t ack;

    IIC_Start();													//start
    IIC_Send_Byte((CACP04_ADDR<<1)&0xFE);	//IIC_Address+W
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Send_Byte(CACP04_OPCode_Test_read);            		//send op_code
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
    IIC_Start();																	//Start
    IIC_Send_Byte((CACP04_ADDR<<1)|0x01);        //IIC_Address+R
    ack = IIC_Wait_Ack();
    if(ack != 0)
    {
        return STATUS_ERR_OVERFLOW;
    }
		ack=IIC_Read_Byte(0);
    IIC_Stop();
		if (ack!=0x11)
		{
			//liyu must
			return 2;
		}
    delay_ms(10);
    return STATUS_OK;
}


const char CACP04_Config_Data[48]={    
	0x1d, 		//00.	7:6 I2C_Address 00; 5:2 OLF_FTUNE Typ., recommended 07; 1:0 OLF_CTUNE 01 : 50kHz
	0x00, 		//01.	7 OX_DIS Default : 0 Disable the OX clock; 5 OX_DIV4 0 : No division, OX clock frequency : Raw freq./ 4; 4 OX_AUTOSTOP_DIS Default : 0; 
//	0x08, 		//02.	内部放电电阻180k 开启
	0x58, 		//02.	内部放电电阻90k 开启
	0x10, 		//03.	PCAUX上的下拉激活 PCAUX正常  充电电阻180k   old 10 90k
	0x83, 		//04.	片内基准;00;激活片上寄生电容的补偿机制并获得补偿; 1001 0011  old is 0x10;//floating 91
	0x00, 		//05. 50kHz
//	0x08, 		//05. 500kHz
	0x0f, 		//06.	EnablePIN:C5 C4 C3 C2 C1 C0;
	0x20,     //07.	low;
	0x00,     //08.	high C_AVRG 32AVRG; 取32次平均
	0xe8, 		//09.	low ConvertTime; 500 to 1000
	0x03, 		//10.	mid ConvertTime;
	0x00, 		//11.	high ConvertTime;  
	0x10, 		//12.	old is 04	DISCHARGE_TIME;  
	0x18, 		//13.	old is 18	C_STARTONPIN:0:PG0;C_TRIG_SEL:0:Continuous;C_TRIG_SEL:2:Timer triggered;DISCHARGE_TIME_high:0  old 08
	0xff, 		//14.	PRECHARGE_TIME:1023(0x03ff)
	0x23, 		//15.	old is 23	C_FAKE:8 fakes 去掉前面8个不稳定测量值;   PRECHARGE_TIME_high:3
	0x00, 		//16.	old is 04	FULLCHARGE_TIME;
	0x28, 		//17.	C_REF_SEL 10pF;    FULLCHARGE_TIME_high:0
//	0x50, 		//17.	C_REF_SEL 20pF;    FULLCHARGE_TIME_high:0
//	0x78, 		//17.	C_REF_SEL 30pF;    FULLCHARGE_TIME_high:0
	0x00, 		//18.	Guard:OP Mode:0:Permanent;Guard: Activate external OP:0:Internal OP;Guard Enable:None C5=0 C4=0 C3=0 C2=0 C1=0 C0=0
	0x00, 		//19.	Guard: OP gain:1.00;Guard: OP attenuation:0.5aF;C_G_TIME:0;
	0x00, 		//20. Cycle-time for the RDC;Guard OP current trim;
	0x01, 		//21.	R_TRIG_PREDIV:Every signal triggers;
	0x00, 		//22.	R_TRIG_SEL:5:CDC asynchronous; R_AVRG:0 : Not averaged; R_TRIG_PREDIV_high 00;
	0x30, 		//23.	RDC_PORT_EN:‘b1x : deActivates port PT1; RDC_PORT_EN_IMES:0:Disabled; RDC_PORT_EN_IREF:00:Disabled; R_FAKE:0: 2fake cycles per average value;R_STARTONPIN:0 : PG0;
	0x73, 		//24.	ams internal bits;
	0x04, 		//25.	ams internal bits;
	0x50, 		//26.	ams internal bits;
	0x08, 		//27.	DSP_MOFLO_EN:00: Off; DSP_SPEED:2:Slow, recommended; PG1xPG3:0:Pulse output at PG3; PG0xPG2:0 : Pulse output at PG2;
	0x5a, 		//28.	WD_DIS:0x5A : Watchdog disabled (off);
	0x00, 		//29.	DSP_STARTONPIN:None PIN; DSP_FF_IN:None;
	0x81, 		//30.	old is 01	PG5_INTN_EN:0 : PG5 <== INTN;	PG4_INTN_EN:0 : PG4 normal operation;	DSP_START_EN:'bxxx1 : Trigger by end of CDC (recommended);
	0x08, 		//31.	脉冲输出控制0寄存器;
	0x08, 		//32.	脉冲输出控制1寄存器;
	0x00, 		//33.	PG_DIR_IN:0 : Output;	PG_PU:0 : Pull-up disabled;PG口配置成全部输出，无上拉。
	0x47, 		//34.	INT_TRIG_BG:0:Disabled;	DSP_TRIG_BG:1:Enabled;	BG_PERM:0:Bandgap pulsed;	AUTOSTART:0 : Disabled; 3:0 :ams internal bits;
	0x40, 		//35.	CDC_GAIN_CORR[7:0]:Recommended 1.25 ==> 0x40;//固件定义的增益校正系数配置。
	0x00, 		//36.	Not used;
	0x00, 		//37.	Not used;
	0x00, 		//38.	BG_TIME:0: Recommended;
	0x71, 		//39.	PULSE_SEL1:7 : Res7 (Alu/Ref @PCap04_standard);	PULSE_SEL0:0 to 5 : Res0 to Res5 (C0..5 /Cref @PCap04_standard);
	0x00, 		//40.	C_SENSE_SEL:Firmware defined;
	0x00, 		//41.	R_SENSE_SEL:Firmware definedBit;
	0x08, 		//42.	ALARM1_SELECT/ALARM0_SELECT:Firmware defined.;  EN_ASYNC_READ:1 : Active;	.....
	0x00, 		//43.	None?;
	0x00, 		//44.	None?;
	0x00, 		//45.	None?;
	0x00, 		//46.	None?;
	0x01,			//47.	RUNBIT:1 : On = the protection is removed, and the system may run;
	//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};
/*
const char CACP04_Config_Data1[48]={    
	0x1d, 		//00.	7:6 I2C_Address 00; 5:2 OLF_FTUNE Typ., recommended 07; 1:0 OLF_CTUNE 01 : 50kHz
	0x00, 		//01.	7 OX_DIS Default : 0 Disable the OX clock; 5 OX_DIV4 0 : No division, OX clock frequency : Raw freq./ 4; 4 OX_AUTOSTOP_DIS Default : 0; 
	0x08, 		//02.	内部放电电阻180k 开启
	0x10, 		//03.	PCAUX上的下拉激活 PCAUX正常  充电电阻180k   old 10 90k
	0x80, 		//04.	片内基准;00;激活片上寄生电容的补偿机制并获得补偿; 1001 0011  old is 0x10;//floating 91
	0x00, 		//05.
	0x3F, 		//06.	EnablePIN:C5 C4 C3 C2 C1 C0;
	0x20,     //07.	low;
	0x00,     //08.	high C_AVRG 32AVRG; 取32次平均
	0xf4, 		//09.	low ConvertTime; 500 to 1000
	0x01, 		//10.	mid ConvertTime;
	0x00, 		//11.	high ConvertTime;  
	0x00, 		//12.	old is 04	DISCHARGE_TIME;  
	0x18, 		//13.	old is 18	C_STARTONPIN:0:PG0;C_TRIG_SEL:0:Continuous;C_TRIG_SEL:2:Timer triggered;DISCHARGE_TIME_high:0  old 08
	0xff, 		//14.	PRECHARGE_TIME:1023(0x03ff)
	0x23, 		//15.	old is 23	C_FAKE:8 fakes 去掉前面8个不稳定测量值;   PRECHARGE_TIME_high:3
	0x00, 		//16.	old is 04	FULLCHARGE_TIME;
	0x24, 		//17.	C_REF_SEL 10pF;    FULLCHARGE_TIME_high:0
	0x00, 		//18.	Guard:OP Mode:0:Permanent;Guard: Activate external OP:0:Internal OP;Guard Enable:None C5=0 C4=0 C3=0 C2=0 C1=0 C0=0
	0x00, 		//19.	Guard: OP gain:1.00;Guard: OP attenuation:0.5aF;C_G_TIME:0;
	0x00, 		//20. Cycle-time for the RDC;Guard OP current trim;
	0x01, 		//21.	R_TRIG_PREDIV:Every signal triggers;
	0x50, 		//22.	R_TRIG_SEL:5:CDC asynchronous; R_AVRG:0 : Not averaged; R_TRIG_PREDIV_high 00;
	0xc0, 		//23.	RDC_PORT_EN:‘b1x : deActivates port PT1; RDC_PORT_EN_IMES:0:Disabled; RDC_PORT_EN_IREF:00:Disabled; R_FAKE:0: 2fake cycles per average value;R_STARTONPIN:0 : PG0;
	0x73, 		//24.	ams internal bits;
	0x04, 		//25.	ams internal bits;
	0x50, 		//26.	ams internal bits;
	0x08, 		//27.	DSP_MOFLO_EN:00: Off; DSP_SPEED:2:Slow, recommended; PG1xPG3:0:Pulse output at PG3; PG0xPG2:0 : Pulse output at PG2;
	0x5a, 		//28.	WD_DIS:0x5A : Watchdog disabled (off);
	0x00, 		//29.	DSP_STARTONPIN:None PIN; DSP_FF_IN:None;
	0x82, 		//30.	old is 01	PG5_INTN_EN:0 : PG5 <== INTN;	PG4_INTN_EN:0 : PG4 normal operation;	DSP_START_EN:'bxxx1 : Trigger by end of CDC (recommended);
	0x08, 		//31.	脉冲输出控制0寄存器;
	0x08, 		//32.	脉冲输出控制1寄存器;
	0x00, 		//33.	PG_DIR_IN:0 : Output;	PG_PU:0 : Pull-up disabled;PG口配置成全部输出，无上拉。
	0x47, 		//34.	INT_TRIG_BG:0:Disabled;	DSP_TRIG_BG:1:Enabled;	BG_PERM:0:Bandgap pulsed;	AUTOSTART:0 : Disabled; 3:0 :ams internal bits;
	0x40, 		//35.	CDC_GAIN_CORR[7:0]:Recommended 1.25 ==> 0x40;//固件定义的增益校正系数配置。
	0x00, 		//36.	Not used;
	0x00, 		//37.	Not used;
	0x00, 		//38.	BG_TIME:0: Recommended;
	0x71, 		//39.	PULSE_SEL1:7 : Res7 (Alu/Ref @PCap04_standard);	PULSE_SEL0:0 to 5 : Res0 to Res5 (C0..5 /Cref @PCap04_standard);
	0x00, 		//40.	C_SENSE_SEL:Firmware defined;
	0x00, 		//41.	R_SENSE_SEL:Firmware definedBit;
	0x08, 		//42.	ALARM1_SELECT/ALARM0_SELECT:Firmware defined.;  EN_ASYNC_READ:1 : Active;	.....
	0x00, 		//43.	None?;
	0x00, 		//44.	None?;
	0x00, 		//45.	None?;
	0x00, 		//46.	None?;
	0x01,			//47.	RUNBIT:1 : On = the protection is removed, and the system may run;
	//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};
*/
const char CACP04_Firmware_DataV0[1024]={
0x22,0x8A,0xA0,0x01,0x20,0x55,0x42,0x5C,0x48,0xB1,0x07,0x92,0x02,0x20,0x13,0x02,//16
0x20,0x93,0x02,0xB2,0x02,0x78,0x20,0x54,0xB3,0x06,0x91,0x00,0x7F,0x20,0x86,0x20,//32
0x54,0xB6,0x03,0x72,0x62,0x20,0x54,0xB7,0x00,0x00,0x42,0x5C,0xA1,0x00,0x49,0xB0,//48
0x00,0x49,0x40,0xAB,0x5D,0x92,0x1C,0x90,0x02,0x7F,0x20,0x86,0x66,0x67,0x76,0x77,//64
0x66,0x7A,0xCF,0xCD,0xE6,0x43,0xF1,0x44,0x29,0xAA,0x7A,0xDC,0xE7,0x41,0x32,0xAA,//
0x01,0x99,0xFD,0x7B,0x01,0x7A,0xCF,0xEB,0xE6,0x43,0xF1,0x44,0x29,0xAA,0x7A,0xC1,//
0xE7,0x41,0x32,0x6A,0xDE,0x44,0x7A,0xCF,0xEA,0xE6,0x43,0xF1,0x44,0x29,0xAA,0x6A,//
0xDF,0x44,0x7A,0xC4,0xE7,0x41,0x32,0xAB,0x05,0x7A,0xC1,0xE1,0x43,0xE0,0x3A,0x7A,//128
0xC0,0xE1,0x43,0xE0,0x3A,0x02,0x7A,0xCF,0xE6,0xE6,0x43,0xF1,0x44,0x29,0xAA,0x7A,//1
0xEF,0x44,0x02,0x20,0x9D,0x84,0x01,0x21,0x2C,0x21,0x70,0x20,0x37,0xC8,0x7A,0xE7,//2
0x43,0x49,0x11,0x6A,0xD4,0x44,0x7A,0xC1,0xD8,0xE6,0x43,0xE9,0x44,0x1C,0x43,0x13,//3
0xAB,0x61,0x6A,0xDE,0x41,0xAB,0x0B,0x46,0x46,0x46,0x7A,0xDF,0xFF,0xFF,0xFF,0xFF,//4
0xE3,0x41,0x32,0x1C,0x44,0xE9,0x13,0x6A,0xD4,0x13,0x41,0xAA,0xDF,0x7A,0xC5,0xE1,//5
0x43,0x49,0xE0,0x34,0x7A,0xCF,0xE3,0xE6,0x43,0xF1,0x44,0x29,0x8A,0xDB,0xC0,0x27,//6
0xD4,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41,0x30,0xAB,0x01,0x86,0x37,0x7A,0xC6,0xE7,//7
0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC1,0xE1,0xE6,0x43,0xE9,0x44,0x25,0xD1,//256
0x7A,0xC6,0xE7,0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC0,0xE7,0x43,0xE9,0x44,//1
0x25,0xD1,0x92,0x10,0x7A,0xE1,0x44,0xE2,0x44,0xE3,0x44,0xE4,0x44,0xE5,0x44,0xE6,//2
0x44,0xE7,0x44,0xE8,0x44,0xC1,0xD8,0x22,0xC3,0x92,0xFF,0x02,0x7A,0xCF,0xD7,0xE6,//3
0x43,0xF1,0x44,0x7A,0xD0,0xE7,0x43,0x29,0xF4,0x32,0xAB,0x03,0x42,0x5C,0x92,0x03,//4
0x7A,0xC0,0xE1,0x43,0xD9,0x27,0x7F,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41,0x32,0xAB,//5
0x01,0x86,0x11,0x7A,0xC2,0x43,0x7A,0xE7,0x44,0x6A,0xC6,0x44,0x7A,0xC3,0x43,0x7A,//6
0xE8,0x44,0x6A,0xC7,0x44,0xC1,0xD4,0x22,0xDC,0x7A,0xC8,0xE1,0x43,0xE0,0x3A,0x02,//7
0x7A,0xCF,0xE7,0xE6,0x43,0xF1,0x44,0x29,0xAA,0x7A,0xC7,0xE1,0x41,0x6A,0xD4,0x45,//384
0x5A,0x25,0x27,0x46,0x46,0x46,0x46,0x7A,0xE9,0x44,0x7A,0xC0,0xE7,0x43,0x55,0x7A,//1
0xEA,0x45,0x7A,0xE9,0x51,0x1C,0x43,0x6A,0xCA,0x44,0x1D,0x43,0x6A,0xCB,0x44,0x7A,//2
0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC,0xE0,0xE6,0x41,0x2C,//3
0x3A,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6,0x43,0xE9,0x44,0x7A,//4
0xC1,0xE1,0x43,0x2C,0x68,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A,0xCD,0x43,0x7A,0xCE,//5
0x44,0x6A,0xCA,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B,0xC8,0xEE,0x44,0x7A,//6
0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC,0xEC,0xE6,0x41,0x2C,//7
0x3A,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6,0x43,0xE9,0x44,0x7A,//512
0xC1,0xE1,0x43,0x2C,0x68,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A,0xCD,0x43,0x7A,0xCE,//528
0x44,0x6A,0xCB,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B,0xC8,0xED,0x44,0x02,//544
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//560

0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//576
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//592
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//608
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//624
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//640
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7A,0xB4,0x03,0xC1,0xD8,0x92,//656
0x0A,0xB5,0x03,0xC1,0xD4,0x92,0x19,0x9F,0x01,0x22,0xED,0x02,0xE6,0x43,0xFB,0x50,//672
0xE9,0x44,0xFA,0x43,0xF9,0x58,0x1C,0x51,0xAD,0x02,0x43,0x59,0x57,0x7D,0x9A,0xEA,//688
0x01,0xE6,0x43,0xFC,0x50,0xE9,0x44,0xFA,0x43,0x1C,0x51,0xAD,0x02,0x43,0x59,0x57,//704
0xB1,0xED,0x02,0x7A,0xE6,0x43,0x7A,0xE9,0x44,0x40,0x5D,0x1C,0x45,0x1A,0x45,0x1A,//720
0x45,0x1A,0x45,0x1A,0x45,0x1A,0x45,0x1A,0x45,0x1A,0x45,0x02,0x7A,0xE6,0x43,0x7A,//736
0xE9,0x44,0x40,0x5D,0x1C,0x45,0x1A,0x45,0x1A,0x45,0x1A,0x45,0x02,0xC1,0xD4,0x22,//752
0xDC,0xC1,0xD8,0x22,0xC3,0x95,0x00,0x78,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//768
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//784
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//800

0xCD,0xCC,0xCC,0x01,0x33,0x33,0x33,0x02,0x01,0x00,0xFE,0x03,0x33,0x33,0x33,0x07,//816
0xCD,0xCC,0xCC,0x08,0x01,0x00,0xFE,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//832
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//848
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//864
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//880
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//896
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//912
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//928
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//944
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//960

0x1D,0x00,0x08,0x11,0x91,0x00,0x3F,0x20,0x00,0xD0,0x07,0x00,0x00,0x18,0xFF,0x23,//976
0x00,0x28,0x00,0x00,0x00,0x01,0x50,0x30,0x73,0x04,0x50,0x08,0x5A,0x00,0x02,0x08,//992
0x08,0x00,0x47,0x40,0x00,0x00,0x00,0x71,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x01,//1008
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1024
};
const char CACP04_Firmware_DataV1[1024]={
0x24,0x05,0xA0,0x01,0x20,0x55,0x42,0x5C,0x48,0xB1,0x07,0x92,0x02,0x20,0x13,0x02,//16
0x20,0x93,0x02,0xB2,0x02,0x78,0x20,0x54,0xB3,0x06,0x91,0x00,0x7F,0x20,0x86,0x20,//32
0x54,0xB6,0x03,0x72,0x62,0x20,0x54,0xB7,0x00,0x00,0x42,0x5C,0xA1,0x00,0x49,0xB0,//48
0x00,0x49,0x40,0xAB,0x5D,0x92,0x1C,0x90,0x02,0x7F,0x20,0x86,0x66,0x67,0x76,0x77,//64
0x66,0x7A,0xCF,0xCD,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xDC,0xE7,0x41,0x32,0xAA,//
0x01,0x99,0xFD,0x7B,0x01,0x7A,0xCF,0xEB,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xC1,//
0xE7,0x41,0x32,0x6A,0xDE,0x44,0x7A,0xCF,0xEA,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x6A,//
0xDF,0x44,0x7A,0xC4,0xE7,0x41,0x32,0xAB,0x05,0x7A,0xC1,0xE1,0x43,0xE0,0x3A,0x7A,//128
0xC0,0xE1,0x43,0xE0,0x3A,0x02,0x7A,0xCF,0xE6,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,//1
0xEF,0x44,0x02,0x20,0x9D,0x84,0x01,0x21,0x2E,0x21,0x74,0x20,0x37,0xC8,0x7A,0xE7,//2
0x43,0x49,0x11,0x6A,0xD4,0x44,0x7A,0xC1,0xD8,0xE6,0x43,0xE9,0x44,0x1C,0x43,0x13,//3
0xAB,0x63,0x6A,0xDE,0x41,0xAB,0x0B,0x46,0x46,0x46,0x7A,0xDF,0xFF,0xFF,0xFF,0xFF,//4
0xE3,0x41,0x32,0x1C,0x44,0xE9,0x13,0x6A,0xD4,0x13,0x41,0xAA,0xDF,0x7A,0xC5,0xE1,//5
0x43,0x49,0xE0,0x34,0x7A,0xCF,0xE3,0xE6,0x43,0xF1,0x44,0x29,0xE0,0xDB,0xC0,0x27,//6
0xE5,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41,0x30,0xAB,0x03,0x86,0x01,0x92,0x37,0x7A,//7
0xC6,0xE7,0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC1,0xE1,0xE6,0x43,0xE9,0x44,//256
0x25,0xE0,0x7A,0xC6,0xE7,0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC0,0xE7,0x43,//1
0xE9,0x44,0x25,0xE0,0x92,0x10,0x7A,0xE1,0x44,0xE2,0x44,0xE3,0x44,0xE4,0x44,0xE5,//2
0x44,0xE6,0x44,0xE7,0x44,0xE8,0x44,0xC1,0xD8,0x24,0x3E,0x92,0xFF,0x02,0x7A,0xCF,//3
0xD7,0xE6,0x43,0xF1,0x44,0x7A,0xD0,0xE7,0x43,0x2A,0x2A,0x32,0xAB,0x03,0x42,0x5C,//4
0x92,0x03,0x7A,0xC0,0xE1,0x43,0xD9,0x27,0x90,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41,//5
0x32,0xAB,0x03,0x86,0x01,0x92,0x11,0x7A,0xC2,0x43,0x7A,0xE7,0x44,0x6A,0xC6,0x44,//6
0x7A,0xC3,0x43,0x7A,0xE8,0x44,0x6A,0xC7,0x44,0xC1,0xD4,0x24,0x57,0x7A,0xC8,0xE1,//7
0x43,0xE0,0x3A,0x02,0x7A,0xCF,0xE7,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xC7,0xE1,//384
0x41,0x6A,0xD4,0x45,0x5A,0x25,0x36,0x46,0x46,0x46,0x46,0x7A,0xE9,0x44,0x7A,0xC0,//1
0xE7,0x43,0x55,0x7A,0xEA,0x45,0x7A,0xE9,0x51,0x1C,0x43,0x6A,0xCA,0x44,0x1D,0x43,//2
0x6A,0xCB,0x44,0x7A,0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC,//3
0xE0,0xE6,0x41,0x2C,0x42,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6,//4
0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x2C,0x70,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A,//5
0xCD,0x43,0x7A,0xCE,0x44,0x6A,0xCA,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B,//6
0xAE,0xEE,0x44,0x7A,0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC,//7
0xEC,0xE6,0x41,0x2C,0x42,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6,//512
0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x2C,0x70,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A,//528
0xCD,0x43,0x7A,0xCE,0x44,0x6A,0xCB,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B,//544
0xAE,0xED,0x44,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//560

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//576
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//592
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//608
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//624
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//640
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//656
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//672
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//688
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//704
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//720
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//736
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//752
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//768
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//784
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//800

0x35,0x33,0x33,0x07,0xCD,0xCC,0xCC,0x08,0x01,0x00,0xFE,0x03,0x66,0x66,0x66,0x01,//816
0x33,0x33,0x33,0x02,0x01,0x00,0xFE,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//832
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//848
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//864
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//880
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//896
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//912
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//928
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//944
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//960

0x1D,0x00,0x08,0x11,0x91,0x00,0x3F,0x20,0x00,0xD0,0x07,0x00,0x00,0x18,0xFF,0x23,//976
0x00,0x28,0x00,0x00,0x00,0x01,0x50,0x30,0x73,0x04,0x50,0x08,0x5A,0x00,0x02,0x08,//992
0x08,0x00,0x47,0x40,0x00,0x00,0x00,0x71,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x01,//1008
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1024
};


bool CACP04_WriteAllConfig()
{
	uint8_t buf[48];
	
	memcpy(buf,CACP04_Config_Data,48);
	if (CACP04_Write_Configuration(0,buf,48)!=STATUS_OK)
	{
		return false;
	}
	return true;
}

bool CACP04_WriteFirmware()
{
	uint8_t buf[1024];

	memcpy(buf,CACP04_Firmware_DataV1,1024);
	if (CACP04_Write_NVRAM(0,buf,960)!=STATUS_OK)
	{
		return false;
	}
	return true;
}


float CapConvertToMoisture(float temp,float humi,float CAP)
{
	float result=0;
	float k_temp,b_temp,k_humi,b_humi,k_cap,b_cap;
	
	result=CAP;
	
	
	return result;
}

float GetCap()
{
	double ValD[4];
//	float Val[3];
	CACP04_init();//IIC init
  delay_ms(5);
	uint8_t buf[10];
	
	if (CACP04_Test_read()!=STATUS_OK)
	{
		return 0;
	}
	
	if (CACP04_Power_on_Reset()!=STATUS_OK)
	{
		return 0;
	}
  delay_ms(20);

	buf[0]=0x00;
	if (CACP04_Write_Configuration(47,buf,1)!=STATUS_OK)
	{
		return false;
	}
	if (CACP04_WriteFirmware()!=true)
	{
		return 0;
	}
	if (CACP04_WriteAllConfig()!=true)
	{
		return 0;
	}
/*
	if (CACP04_Power_on_Reset()!=STATUS_OK)
	{
		return 0;
	}
  delay_ms(20);
*/
	if (CACP04_Initialize()!=STATUS_OK)
	{
		return 0;
	}
	
	
	if (CACP04_CDC_Start_Conversion()!=STATUS_OK)
	{
		return 0;
	}
  delay_ms(300);/*
	if (CACP04_RDC_Start_Conversion()!=STATUS_OK)
	{
		return 0;
	}
  delay_ms(5000);
	*/
	//read status
	if (CACP04_Read_Status(0,buf))
	{
		return 0;
	}
	if (CACP04_Read_Status(1,&buf[1]))
	{
		return 0;
	}
	if (CACP04_Read_Status(2,&buf[2]))
	{
		return 0;
	}
	if (CACP04_Read_Result(0,&ValD[0]))//0 -> C1/C0
	{
		return 0;
	}
	if (CACP04_Read_Result(1,&ValD[1]))//0 -> C3/C2
	{
		return 0;
	}
	if (CACP04_Read_Result(2,&ValD[2]))//0 -> C5/C4
	{
		return 0;
	}
	if (CACP04_Read_Result(3,&ValD[3]))//0 ->  
	{
		return 0;
	}
	/*
	Val[0]=ValD;
	if (CACP04_Read_Result(1,&ValD))//0 -> C2&C3
	{
		return 0;
	}
	Val[1]=ValD;
	Val[2]=Val[1]-Val[0];*/
	sensorReal.ph3_2000=ValD[1]*1000;
	sensorReal.ph3_5=ValD[0]*10;
	
	return sensorReal.ph3_2000;
}

float GetMoisture(float temp,float humi)
{
	float Cap;
	Cap=GetCap();
	return CapConvertToMoisture(temp,humi,Cap);
}



